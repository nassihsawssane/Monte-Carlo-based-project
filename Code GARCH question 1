import numpy as np
import pandas as pd

np.random.seed(42)

# Fonction de log-vraisemblance conditionnelle du modèle GARCH log(L(r/w))
def likelihood(returns, omega1, omega2, omega3):
    T = len(returns)
    h = np.zeros(T)
    h[0] = np.var(returns) # à la première valeur de h on associe la variance des taux d'intérêt.
    
    for t in range(1, T):
        h[t] = omega1 + omega3 * h[t-1] + omega2 * (returns[t-1] ** 2)
    
    L = np.prod(1/np.sqrt(2*np.pi*h) * np.exp(-0.5*(returns**2)/h))
    return L

# Distribution a priori de (w1, w2, w3). Les oméga sont indépendants et sont de distribution normale centrée.
def prior(omega1, omega2, omega3, var_1, var_2, var_3):
    return np.exp((-1/2)*((omega1**2)/(var_1) + (omega2**2)/(var_2) + (omega3**2)/(var_3)))


# Probabilité de transition de x vers y et de y vers x 
def q(x, y, var):
    return (1 / np.sqrt(2 * np.pi * var**2)) * np.exp(-(y - x)**2 / (2 * var**2))
#si on suppose que q c'est une gaussienne et que q(x,y)=q(y,x) alors on n'a plus de q dans l'expression de r.


#Pi est la distribution de (w1, w2, w3) sachant r, est proportionnelle à la distribution du vecteur des r sachant (w1, w2, w3) * la distribution a priori de (w1, w2, w3).

def generateur_Metropolis(returns, omega1_current, omega2_current, omega3_current, n_iter, burn_in, var_2, var_3, var_1=0.01):

    L=[]

    for i in range (0,n_iter):

# Proposer un nouveau jeu de paramètres omega qui correspond à Y et omega_current c'est Xn-1.
        omega1_n = omega1_current + np.random.normal(0, var_1) # var = variance
        omega2_n = omega2_current + np.random.normal(0, var_2)
        omega3_n = omega3_current + np.random.normal(0, var_3)

# Fonction pour calculer r(x, y)
        q_ratio = q(omega1_current, omega1_n, var_1) * q(omega2_current, omega2_n, var_2) * q(omega3_current, omega3_n, var_3) /\
              (q(omega1_n, omega1_current, var_1) * q(omega2_n, omega2_current, var_2) * q(omega3_n, omega3_current, var_3))  # dans notre cas q_ratio est normalement égal à 1.
    
        r = ((prior(omega1_n, omega2_n, omega3_n, var_1, var_2, var_3) * likelihood(returns, omega1_n, omega2_n, omega3_n))/(prior(omega1_current, omega2_current, omega3_current, var_1, var_2, var_3) * likelihood(returns, omega1_current, omega2_current, omega3_current))) * q_ratio
        #formule prise dans les slides du cours.

# algorithme pour affecter une valeur à Xn : 
        if np.random.uniform() < min(1,r) : 
            omega1_current = omega1_n # avec proba min(1,r), Xn=Y.
            omega2_current = omega2_n
            omega3_current = omega3_n

# on prend uniquement les paramètres omega obtenus après les étapes de burn-in.
        if i > burn_in :
            L.append ([omega1_current, omega2_current, omega3_current])

    return L



# Paramètres initiaux
omega1_current = 0.1
omega2_current = 0.1
omega3_current = 0.8

# Générer les rendements simulés pour le test
returns = np.random.normal(0, 1, 1000)

# Tableau de returns réels à partir d'un tableau de taux de change.

df = pd.read_excel('chemin_vers_ton_fichier.xlsx')
df = df.sort_values('Date')
df = df.dropna(subset=['USD/EUR'])
df['Returns'] = df['USD/EUR'].pct_change() * 100